#!/usr/bin/env python

"""
%CONDPOT Return a potential conditioned on another variable
% newpot = condpot(pot,x,y)
% condition the potential to return potential with distribution p(x|y),
% summing over remaining variables. If y is empty (or missing), return the
% marginal p(x).
% If both x and y are missing, just return the normalised table
"""
import numpy as np
from .potential import potential
from setminus import setminus
from copy import copy
from sumpot import sumpot


def condpot(pots, x=[], y=[]):
    if isinstance(pots, potential):
        pots = [pots]
    else:
        pots = list(pots)

    x = np.array(x)
    y = np.array(y)
    
    for pot in pots:
        other_axis = setminus(pot.variables, y)
        other_axis = setminus(other_axis, x)
        pxy = sumpot(pot, other_axis)
        py = copy.deepcopy(pxy)
        py = sumpot(pxy, x)
        pot = pxy / py

    if len(pots) == 1:
        return pots[0]
    else:
        return pots
    """
    other_axis = setminus(pots
    if y.size == 0:
        intersection, ix, ipot = intersect(x, pot.variables)
        newpot.variables = intersection
        FULL_axis = np.arange(pot.variables.size)
        axis_intersection = ipot
        other_axis = setminus(FULL_axis, axis_intersection)
        newpot.table = np.apply_over_axes(np.sum, pot.table, other_axis)
        newpot.table = newpot.table / np.sum(newpot.table)
    else:

    return newpot
    """
